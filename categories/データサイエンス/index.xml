<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>データサイエンス on KBSIs' Blog</title><link>https://idichi.tk/categories/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9/</link><description>Recent content in データサイエンス on KBSIs' Blog</description><generator>Hugo -- gohugo.io</generator><language>jp</language><lastBuildDate>Tue, 15 Dec 2020 15:16:05 +0900</lastBuildDate><atom:link href="https://idichi.tk/categories/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B5%E3%82%A4%E3%82%A8%E3%83%B3%E3%82%B9/index.xml" rel="self" type="application/rss+xml"/><item><title>K近傍法をスクラッチ実装してみる</title><link>https://idichi.tk/blog/knn/</link><pubDate>Tue, 15 Dec 2020 15:16:05 +0900</pubDate><guid>https://idichi.tk/blog/knn/</guid><description>k近傍法とはなにか クラス分類の機械学習の一種のアルゴリズムのこと．
k近傍法は学習させるデータ（クラス属性含めて）一つ一つに対して入力データとの類似度（距離）を求め，類似度が高いデータのクラスを入力データのクラスとする．
手順は
すべてのデータに対して類似度を求め，高いものから順にk個データを選ぶ． それらのデータのクラスを多数決で決定し，そのクラスとする． なお，距離はユークリッド距離でもよいし，マハラノビス距離でもよい（らしい）
kの値は，線形探索や，交差検証などによって，決定する．（ハイパラメータなので）
スクラッチ実装 上記手順を見ればまったく難しくなさそうなので，簡単に実装してみる．
import numpy as np ## データとクラス（属性）の構造体替わり class Data: def __init__(self,vec:np.array,spector:str) -&amp;gt; None: self.vec=vec self.spec=spector ## 学習データ A=np.random.randint(0,100,(10)) B=np.random.randint(0,100,(10)) C=np.random.randint(0,100,(10)) D=np.random.randint(0,100,(10)) E=np.random.randint(0,100,(10)) VectorsArray=[Data(A,&amp;#39;A&amp;#39;),Data(B,&amp;#39;B&amp;#39;),Data(C,&amp;#39;A&amp;#39;),Data(D,&amp;#39;B&amp;#39;),Data(E,&amp;#39;A&amp;#39;)] ## 類似度（ユークリッド距離）を求める関数 def getDistance(vec:np.array,vec2:np.array): r=np.linalg.norm(vec-vec2,ord=2) return r &amp;#39;&amp;#39;&amp;#39; - K近傍法メインルーチン 引数 vec:入力データ(np.array) VectorsArray:Data構造体のリスト k : 整数 返却値 {str(クラス):count(クラスの数)...} 利用時は,max関数でkeyを指定する． 詳細は__main__()で &amp;#39;&amp;#39;&amp;#39; def getNearVecSpec(vec:np.array,VectorsArray=VectorsArray,k=3) : distance=[] for v in VectorsArray: d=getDistance(vec,v.vec) distance.append((v.spec,d)) distance.sort(key=lambda X: X[1]) print(distance) diss={} for i in range(k): v=distance[i] spec=v[0] if spec in diss: diss[spec]+=1 else: diss[spec]=1 return diss if __name__ == &amp;#34;__main__&amp;#34;: a=np.</description></item></channel></rss>